---
typora-copy-images-to: ../../../../../Documents/typro
---

# 目录

[TOC]

# 一、实验目的

1. 在内核实现多进程的二状态模，理解简单进程的构造方法和时间片轮转调度过程。
2. 实现解释多进程的控制台命令，建立相应进程并能启动执行。
3. 至少一个进程可用于测试前一版本的系统调用，搭建完整的操作系统框架，为后续实验项目打下扎实基础。

# 二、实验环境

面对越来越大的工程量，本次实验主要使用CLion IDE完成。CLion+remote gdb远程调试测试没问题，但实际使用上还是bochs查看寄存器、汇编指令更方便，更适合于操作系统调试。其余环境与之前实验大致相同。

# 三、实验特色

本次实验对我的操作系统是一次巨大改进**底层改进**：

1. 实现了使用ATAPI方式的IDE**硬盘驱动程序**，支持读写IO。进入内核后彻底摆脱了bios中断，实现了操作系统的完全自给自足。

2. 在此基础上，进入了**保护模式**。完成了gdt、idt设置，保护模式exception处理，8259A芯片的初始化和硬件中断号重新映射，原本的功能全部能够正常执行。

3. 利用保护模式的“保护“特性，实现了**"蓝屏"**功能，在内核出现错误时会显示错误类型、错误代码出错的CS：EIP，有效地帮助了代码编写和调试。

4. 实现了bochs的**符号调试**和**输出到bochs控制台**。方便了调试，也使得进程切换过程能在控制台里可视化出来。

5. 实现了检测可用的硬件内存。

6. 重构代码，删除了前几次实验中写的，目前不再使用的代码，重新项目结构使之更加合理。

   目前的文件如下：

   ```c
   driver					//设备驱动
   ├── Makefrag			
   ├── cmos.cpp			//cmos驱动(用于读取时间)
   ├── cmos.h
   ├── ide.cpp				//ide硬盘驱动
   ├── ide.h
   ├── kb.c				//键盘驱动
   ├── kb.h
   ├── vga.cpp				//显示设备驱动(本次实验将清屏、设置光标以及操作显存这些与设备之间相关的功能与tty分离放到本文件中)
   └── vga.h
   include
   └── defines.h			//HHOS公共头文件定义
   kernel					//内核实现
   ├── Makefrag
   ├── bin_loader.h		//用户程序加载器
   ├── kernel_main.cpp		//内核C++主程序
   ├── kernel_start.S		//内核入口(汇编)，包含了多个中断服务程序定义
   ├── sh.h				//shell
   └── tty.h				//tty
   kernel_lib				//底层内核库
   ├── Makefrag
   ├── debug_printf.cpp	//向bios控制台输出的debug printf程序
   ├── debug_printf.h
   ├── fault.cpp			//安装Intel x86异常中断程序
   ├── gdt.cpp				//gdt定义和安装函数
   ├── idt.cpp				//idt定义和安装函数
   ├── irq.cpp				//8259A芯片的设置并安装默认硬件中断处理程序
   ├── isr.cpp				//提供isr_init接口
   ├── isr.h
   ├── pic.h				//8259A芯片相关宏定义
   ├── pm.h				//保护模式相关宏定义
   ├── pm.inc				//保护模式相关宏定义(汇编用)
   ├── pm_utility.asm		//保护模式相关工具函数
   ├── sys_utility.cpp		//内核工具函数
   ├── sys_utility.h		
   └── sys_utility_asm.asm	//内核工具函数(汇编写，大部分已经移动到kernel_start.S中，计划实验七弃用该文件)
   libc					//C函数库，与标准C函数库文件名相同
   ├── Makefile
   ├── Makefrag
   ├── assert.h
   ├── cstart.S
   ├── ctype.cpp
   ├── ctype.h
   ├── stdio.cpp
   ├── stdio.h
   ├── stdlib.cpp
   ├── stdlib.h
   ├── string.cpp
   ├── string.h
   ├── sys					//HHOS系统调用接口
   │   └── hhos.h
   ├── test.cpp
   ├── time.cpp
   ├── time.h
   └── unistd.h
   proc					//实先进程
   ├── Makefrag
   ├── proc.cpp
   └── proc.h
   usr						//用户程序
   ├── Makefrag
   ├── bc.cpp				//计算器程序(目前处于弃用状态)
   ├── calc.cpp
   ├── common.asm			//弹射字符程序公共部分
   ├── help.rec			//中断帮助
   ├── linker.ld			//用户程序链接参数
   ├── record.rec			//用户程序目录文件
   ├── sleep.cpp			//测试sleep调用
   ├── test.cpp			//系统调用功能和C函数库测试程序
   ├── user1.asm			//4个弹射字符程序
   ├── user2.asm
   ├── user3.asm
   ├── user4.asm
   ├── user5.asm
   ├── usr1.cpp			//多进程测试程序，显示“In User Process N"
   ├── usr2.cpp
   ├── usr3.cpp
   └── usr4.cpp
   ```

   效果预览：主界面

   ![image-20180427211942310](/Users/lixinrui/Documents/typro/image-20180427211942310.png)

   4进程交替执行

   ![image-20180427184448312](/Users/lixinrui/Documents/typro/image-20180427184448312.png)

   

# 四、实验方案

## （一）、硬盘驱动程序

在保护模式下已经无法使用BIOS中断读取软盘，为了读取用户程序，我选择实现IDE硬盘驱动程序，使用ATAPI类型的PIO方式读写硬盘，过程是：

1. 调用ide_rw函数，将ide_request类型的硬盘请求结构体加入到硬盘请求队列中。并调用ide_deal_req处理位于队头的请求。
2. 对于写入操作，直接通过端口编程向硬盘发送指令，用lba28格式指定写入扇区号，然后用向数据端口写入数据即可。
3. 对于读取操作，要首先指定写入扇区号并并发送写入指令，硬盘在后台进行读取，此时可以进行其他操作。
4. 硬盘读取结束后，会发送IRQ 14，引发相应的中断处理程序sys_ide_handler，在处理程序中读取硬盘数据端口即可读取到硬盘内容。此时会调用ide_deal_req处理请求队列中下一个请求。

上面提到的函数和结构的实现在ide.cpp和ide.h中。

## （二）、保护模式

实现保护模式分为以下几个过程：

1. 修改引导器，在引导器中加载gdt，执行开启A20 line和启动保护模式的代码，此时处理器已经运行在保护模式下，执行一个jmp指令修改CS为保护模式的代码段selecotr、清除指令流水线并跳转到内核。

2. 有了保护模式广阔的内存空间，我首先使用movs指令将内核移动到0x100000的高内存中，一劳永逸地躲开了1M以下内存中的“狼窝”。由于之前设置的gdt保存在1M内存下，这里要重新安装在内核中定义的gdt。栈指针设为0x7c00。相关代码在kernel_lib/pm_utility.asm，kernel/kernel_start.S中。

3. 设置idt并为0到31号Intel异常中断设置“蓝屏”处理程序。这里用到了NASM宏批量生成这三十二个异常处理程序。相关代码在kernel/idt.cpp，kernel/fault.cpp和kernel_lib/pm_utility.asm中。

   下图是在一个13号异常发生时的蓝屏程序截图，它显示了错误类型13（一般保护错误），错误码（Intel文档说明其含义是引发错误的指令指针），出错时的CS：EIP（这一条信息是十分有用的，极大地帮助了我调试内核错误）。

   目前这个蓝屏程序还是有局限性的。因为改程序本身显示错误信息有许多指令要执行，在系统处于严重错误时（例如多个段寄存器都错了），“蓝屏”程序自身可能引发二重异常，这是还得回到依靠bochs来鉴定错误。

   ![image-20180427202824614](/Users/lixinrui/Documents/typro/image-20180427202824614.png)

4. 初始化8259A芯片，并将0-15号IRQ映射到32-47号中断。默认同样安装“蓝屏”中断处理程序。相关代码在kernel/irq.cpp中。

5. 进入C++编写的kernel_main内核主程序（在kernel/kernel_main.cpp中）。使用C++编写的代码基本可以直接移植到保护模式下，而使用汇编及内联汇编编写的代码，要修改设置段寄存器的操作。

## （三）、进程

###(1).基本原理

本次实验的进程切换部分完全是我自己摸索出来的。基本原理是：proc.cpp中以内核数据区全局变量方式定义了MAX_PROC个PCB（暂定为4个），使用一个双向链表pcb_que储存当前已经加载的进程的PCB，时钟中断到来时，当前进程状态保存到PCB中，pcb_que指向pcb_que->next，加载PCB并切换到下一个进程。

### (2). 具体实现

在定义PCB之前，我首先定义了CPU_INFO类如下，该定义中各变量顺序是**精心设计**的，在切换进程push各个寄存器后，**栈中相当于就存在一个该结构体**，以当前esp为参数调用save函数，就可以在save函数中访问到这一结构体。

```c++
struct CPU_INFO{
    /* segment registers */
    uint32_t gs;    // 16 bits
    uint32_t fs;    // 16 bits
    uint32_t es;    // 16 bits
    uint32_t ds;          // 16 bits

    /* registers save by pusha */
    uint32_t edi;
    uint32_t esi;
    uint32_t ebp;
    uint32_t esp;
    uint32_t ebx;
    uint32_t edx;
    uint32_t ecx;
    uint32_t eax;

    /* save by int instruction */
    uint32_t eip;
    uint32_t cs;    // 16 bits
    uint32_t eflags;
}__attribute__((packed));
```

PCB在CPU_INFO上增加了进程id，下一个PCB指针，进程状态三个属性。在内核启动时，proc_init函数初始化4个PCB的id分别为1,2,3,4，状态设为PROC_STAT_NOT_READY，即未载入内存。进程状态目前共定义以下四个：

```c++
#define PROC_STAT_NOT_READY 0		//该进程控制块不在链表中(尚未使用)
#define PROC_STAT_READY 1			//新建态，已经将新的PCB加入链表且程序已经载入内存，尚未运行
#define PROC_STAT_RUNNING 2			//运行态
#define PROC_STAT_WAITING 3			//就绪态
```

载入新的进程时，首先使用sys_read_hard_disk将用户程序载入内存，然后调用new_proc函数，该函数首先调用get_pcb函数，如果有尚未使用的PCB，该函数将一个加入pcb_que中。然后调用0x92系统调用（sys_new_proc），它首先依据当前PCB的id算出对应进程的代码段和数据段selector，然后使用push指令在栈中“创造“出CPU_INFO结构体，并调用save函数保存之。之后将PCB的esp项初始化为0x1000h * id。IP初始化为.proc_ready_begin，这个标号开始时进程真正开始的点。该进程被设为新建态。

在加载完所有进程后，调用set_pit_freq(1)，将load_ready标志位设置为1，时钟中断检测到后，将开始进程调度过程：如果当前进程是新建态，直接载入该进程。如果是运行态，则首先用当前状态更新PCB。

这里有一个要点是：**要在保存的PCB中把esp的值加0xC**，0xC是保护模式下普通的中断调用压入的eflags、CS、EIP在栈中占用的大小。不这样做，每次保存状态esp就和实际切换时的esp减少12，导致运行一段时间后耗尽堆栈，触发一般保护错误，系统停机。

调用round_robin切换PCB，然后从新的PCB中读出处理器状态并修改。esp在最后载入，修改后已近进入新的线程的堆栈地址区域，再压入cs:EIP（此时已近要指定段前缀来访问内核数据段），执行retf，切换到保存的地址处。

**上述过程其实有一个大坑，在实验心得部分将叙述。**

## (四)、bochs调试符号调试**和**输出到bochs控制台

bochs有一个名为port_e9_hack的功能，在bochsrc中指定启用该功能，再向E9端口输出一个字符，该字符就会显示在bochs控制台中。效果如下，可见我的操作系统的输出被输出到了物理机的控制台中，我可以上下滚动查看所有输出历史，也可以只将部分后台日志输出到这里，极大方便了调试。![image-20180427223932351](/Users/lixinrui/Documents/typro/image-20180427223932351.png)

实现bochs调试符号功能旨在解决bochs调试中的不方便之处：

- bochs默认的调试方法不能显示当前指令处在哪个函数中


- bochs也只能根据指令地址设置断点，很多时候只能通过一次次尝试的方式测试出一个函数的地址（反编译结果不准确），很耗时间。

该操作使bochs支持像gdb那样依据函数名设置断点，并显示当前指令处于哪个函数，方便调试，节约时间。

实现分两步

#### 1. 生成符号文件

bochs支持的符号文件其实格式很简单也很直接：类似下图，前面是地址，后面是函数名，中间一个空格，就是提供函数名和地址的对应关系而已。

![image-20180427223610073](/Users/lixinrui/Documents/typro/image-20180427223610073.png)

手动写这个文件当然不现实。因此下面的操作的目的就是要自动生成一个这样的文件。

我目前研究出的方法适用于gcc：思路是使用nm（gcc-i686软件包中包含这个）从elf文件中提取出符号文件。ld如果不加--oformat binary选项默认生成的就是elf文件。由于tlink不支持生成elf文件，以下命令不适用，可能有其他命令可以生成。

假设elf文件名是kernel.elf直接执行`nm kernel.elf > kernel.map`，发现生成的kernel.map文件已近很类似我们想要的了，然而还差一点（地址前面没有0x，中间还多了一列）

![image-20180427223701087](/Users/lixinrui/Documents/typro/image-20180427223701087.png)

解决办法是使用awk工具，这是一个文件处理工具，所有Linux系统均自带，Windows版可以在https://sourceforge.net/projects/gnuwin32/files/gawk/3.1.6-1/gawk-3.1.6-1-bin.zip/download?use_mirror=jaist&download=下载。

`awk '{print "0x"$1,$3}'kernel.map > kernel.map`

现在生成的kernel.map文件就完全可以加载了。

#### 2. 设置bochs加载符号文件

假设kernel.map在当前路径下，在bochsrc中加上一行debug_symbols: file=kernel.map即可

## （五）、显示内存情况

保护模式可以访问到4G的巨大内存，然而在很长一段时间里面PC的内存是没有达到4G的，我目前给操作系统分配的只有32MB。检查实际有多少内存是在进入保护模式前，在BootLoader中尚能使用BIOS中断时，调用0x15中断实现的。（get_mem_map），循环调用它将内存区块信息存放在0x500开始的地址中。内存地址区块信息是一个20bytes的结构体。读到最后一块时ebx==0，结束。

进入内核主函数后，使用C++代码输出信息（此时堆栈几乎不可能已经覆盖了0x500附近区域），效果如下：

![image-20180427225134990](/Users/lixinrui/Documents/typro/image-20180427225134990.png)

可见，内存共分5块，值得注意到是0x1000000之后0x1ef0000的区域，它是主要的可用内存区域，换算出是30.9375mb。最后一个区块似乎是一个虚拟的区块，因为起始和终止地址是在4G附近。



# 五、实验结果

上文实验方案部分已经展示了操作系统主界面、“蓝屏”界面、内存检测的截图。这里主要展示进程执行的演示。

同时在视频录像文件夹中有录像可看。

#### 图一：运行四个弹射字符进程

如图所示，四个进程同时运行。同时bochs控制台输出了进程切换的记录信息。

![image-20180427230426847](/Users/lixinrui/Documents/typro/image-20180427230426847.png)



#### 图二：运行四个循环输出程序

这里运行了四个功能为不断输出“In User Process N"的程序。从这个截图可以看出，一个切换进程的时间片大约可以在一个用户程序中执行3次puts函数。输出中有一些混乱的情况，这说明进程切换发生在puts函数执行一般的过程中。

![image-20180427230637688](/Users/lixinrui/Documents/typro/image-20180427230637688.png)



#### 图三：在多进程运行中测试系统调用和C函数

这里运行了四个我在上次实验中编写的，测试系统调用和C函数库的测试程序。上面一张是单个进程运行的情况，下面一张是4个进程交替运行的情况，可见我实现的系统调用和C函数在目前的多进程实现中是可以正常执行的。但我计划在下个实验中再实现进程退出和多进程的输入。目前输入exit是无法退出到终端的。

![image-20180427231341170](/Users/lixinrui/Documents/typro/image-20180427231341170.png)

![image-20180427231205671](/Users/lixinrui/Documents/typro/image-20180427231205671.png)



# 六、实验总结

本次实验花费了我从上周六开始到现在整整一周时间，包括周三中午十二点到周四中午十二点一个连续24个小时不断的通宵，真的是刻骨铭心了。由于本次实验我使用的CLion IDE尚未配置代码时间统计，因此无法提供像上一个实验那样的具体时间统计了。

基于上次实验4/5时学习保护模式的理论基础，在本次实验中我终于实现了保护模式，算是了却了我很多年来的执念。现在回头看来，保护模式的核心就是段寄存器不再储存具体的段地址，而是储存gdt数组的下标，即增多了一层映射，从而能指定32位的段地址，并设置该段的长度、属性，从而实现保护。然而实现保护模式真的是很麻烦的，这种繁杂性来自于“历史问题”：结构被安排地七零八落的gdt结构，如今毫无意义的A20 line，和硬件中断号冲突的x86异常，都为了兼容性被永久地保留了下来，成为实现保护模式过程中必须克服的问题。当年初二接触到Orange's一书时看到这些真的是吓得要死，上一个寒假时看的时候也都还很头大。可见凌老师的从实模式开始原型进化路线的操作系统实现模式的确是很正确的。

上面提到本次实验遇到**一个大坑**：这个坑是体现为：用户程序大部分情况下执行正常，只有在执行部分C函数（如printf）时执行出现奇怪的错误：直接传进去的字符串能正常显示，但格式化输出的变量不能显示。这个调试过程是异常痛苦的。经过一步步的拍错，我发现printf在内核中工作正常，说明这个函数没有写错。用户程序执行多数代码都是正确的，甚至执行任意没有涉及变量的printf语句也是正确的。这时我试图从指令级别分析发生了什么，printf本身已经是很复杂的函数了，又由于加载用户程序依赖磁盘中断、因此我还不能在调试前关中断。在bochs调试的几秒钟内，生成的指令记录已经有好几MB了。导致这个方法根本行不通。最后我把目光聚集在实现printf可变参数所依赖的valist参数和va_arg宏上。这时我终于找到了问题！valist保存的实际上是一个指向堆栈的地址，va_arg实际是对该地址进行**解引用**。解引用的汇编指令是一个直接寻址，而这个直接寻址的**段前缀是ds**！ 后来才明白这是C/C++的内存模型所决定的，它们认为自己是在一个平坦内存的我实现的是各个用户程序**堆栈段均以0位基地址**，以栈指针初始地址的不同来区分各个栈。而为了**使得每个程序代码和数据段的逻辑地址相同**（这样每个程序就可以使用同样的链接参数），**每程序的cs和ds段地址分别不同，但都不是堆栈段的段地址**。这样就出现了错误。我目前使用的解决方法是用来一个比较技巧性的方法：使用C++的模板功能和内联汇编功能，实现一个强制以ss为前缀进行解引用的va_arg。

```c++
template <typename T>
T my_va_arg(va_list ap)
{
    ap += sizeof(T);
    T* addr = (T *)(ap - (sizeof(T)));
    T ret;
    asm volatile(
    "movl %%ss:(%1), %0"
    :"=r"(ret)
    :"r"(addr)
    );
    return ret;
}
```

如果想避免这个问题，由于在调用系统调用时必然涉及到切换段，在段式内存管理的情况下，只有舍弃让各个程序认为自己有相同逻辑地址的想法，才能做到都以各段都以0位基地址，从而解决这个问题。然而我决定，**在下个实验中，开启保护模式的分页功能**，这样就可以在平坦内存模式下，通过页表的映射，让各个程序的数据段和堆栈段地址相同时，又用相同的逻辑地址，在物理内存上却不会产生冲突，完美地解决有关问题。

在经历精简代码后，目前代码量为5000行，仍比上次实验增加了1500行。这也是我第一个上5000行代码量的项目，感觉越过了一个门槛，挺自豪的哈哈。

![image-20180428020210379](/Users/lixinrui/Documents/typro/image-20180428020210379.png)

# 七、参考文献

为了完成本次实验我借来和买来了以下5本源码分析及保护模式的此外还参考了《Orange's》和一个开源项目OS67的代码，没有这些代码和书籍作为参考，我无法完成本次实验的保护模式及硬盘驱动编写。

![image-20180427233854849](/Users/lixinrui/Documents/typro/image-20180427233854849.png)


​	

 